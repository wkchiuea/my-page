---
title: Design Patterns
date: 2026-02-24
category: Software Engineering
tag: 
image: 
---

**Design patterns** are reusable solutions to common problems in software design. They give a shared vocabulary and a proven structure so that systems stay maintainable and easier to extend. This article lists several well-known patterns and then introduces two in more detail: **Strategy** and **Observer**.

## Overview of design patterns

Patterns are often grouped as follows:

- **Creational**: How objects are created (e.g. **Singleton**, **Factory**, **Builder**).
- **Structural**: How objects are composed (e.g. **Adapter**, **Decorator**, **Facade**, **Proxy**).
- **Behavioral**: How objects interact and distribute responsibility (e.g. **Strategy**, **Observer**, **Command**, **Template Method**).

Other useful patterns include **Repository** (abstract data access), **Dependency Injection** (inverting dependencies), and **MVC/MVVM** (separating UI, logic, and state). Below we focus on **Strategy** and **Observer**.

## Strategy pattern

The **Strategy** pattern defines a family of algorithms (or behaviors), encapsulates each one, and makes them **interchangeable**. The client depends on an abstraction (e.g. an interface) rather than a concrete implementation.

**Use when:** You have multiple ways to do the same thing (e.g. sort by different keys, different payment methods, different export formats) and want to switch or add behaviors without changing client code.

**Example idea:** A `PaymentProcessor` accepts a `PaymentStrategy` (e.g. `CreditCard`, `PayPal`). To add a new payment method, you add a new strategy class and pass it in; no change to the processor.

**Benefits:** Open/closed—open for extension (new strategies), closed for modification (existing code unchanged). Easier to test by injecting mock or stub strategies.

## Observer pattern

The **Observer** pattern defines a **one-to-many** dependency: when one object (the **subject**) changes state, all its **observers** are notified and updated. This decouples the subject from who uses its data.

**Use when:** One part of the system must react to changes in another (e.g. UI updating when data changes, caches invalidating when records change, event-driven pipelines).

**Example idea:** A `DataSource` holds values; multiple `Widget`s subscribe to it. When the data changes, the subject calls `notifyObservers()` and each widget updates. Modern variants include **publish–subscribe** (pub/sub), where subscribers don’t know the publisher.

**Benefits:** Loose coupling between subject and observers; new observers can be added without changing the subject. Fits well with reactive and event-driven architectures.

---

Using patterns like **Strategy** and **Observer** helps keep code modular and easier to change; apply them where they match the problem rather than for their own sake.
