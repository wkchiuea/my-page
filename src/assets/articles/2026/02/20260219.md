---
title: Spring Serialization
date: 2026-02-19
category: Backend
tag: 
image: 
---

**Serialization** in Spring (and Java in general) is the process of converting Java objects into a format that can be stored or transmitted—such as bytes (Java serialization), JSON, or XML—and **deserialization** is the reverse. Spring uses serialization when reading/writing HTTP bodies, caching, messaging, and persistence.

## Introduction

When your Spring application sends or receives data (e.g. REST APIs), it must convert between in-memory objects and the wire format:

- **Outbound**: Object → JSON/XML/bytes (serialize).
- **Inbound**: JSON/XML/bytes → Object (deserialize).

Spring Boot uses **Jackson** by default for JSON. It maps JSON fields to Java fields (getters/setters or record components) and can use annotations such as `@JsonProperty`, `@JsonIgnore`, and `@JsonFormat` to control the mapping.

Java’s built-in serialization (`Serializable`, `ObjectOutputStream`/`ObjectInputStream`) is used when you store or send **Java objects as bytes** (e.g. some caches or message queues). Spring does not use this for HTTP by default; HTTP is typically JSON or XML.

## When it is required and its usage

**When serialization is required:**

- **REST controllers**: Request body → DTO/entity (deserialize); return value → JSON/XML (serialize).
- **Caching**: Storing objects in Redis or a local cache often requires a serialization format (e.g. JSON or Java serialization).
- **Messaging**: Sending objects through Kafka, JMS, or RabbitMQ requires a chosen format (JSON is common).
- **Sessions**: Storing session attributes (e.g. in a database or Redis) may require serialization.

**Usage in Spring:**

- **JSON (REST)**: Add `spring-boot-starter-web`; use `@RequestBody` and return entities/DTOs. Configure Jackson via `ObjectMapper` or properties (`spring.jackson.*`).
- **Custom types**: Use Jackson modules or custom serializers/deserializers when default behavior is not enough (e.g. custom date format, polymorphic types).
- **Validation**: Combine with `@Valid` and Bean Validation so invalid payloads are rejected before they become domain objects.

Understanding serialization helps you design DTOs, control API contracts, and integrate safely with caches and message brokers.
